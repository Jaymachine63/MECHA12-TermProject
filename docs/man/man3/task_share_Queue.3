.TH "task_share.Queue" 3 "MECHA-12 Romi" \" -*- nroff -*-
.ad l
.nh
.SH NAME
task_share.Queue \- A queue which is used to transfer data from one task to another\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBtask_share\&.BaseShare\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB__init__\fP (self, type_code, size, thread_protect=False, overwrite=False, name=None)"
.br
.RI "Initialize a queue object to carry and buffer data between tasks\&. "
.ti -1c
.RI "\fBput\fP (self, item, in_ISR=False)"
.br
.RI "Put an item into the queue\&. "
.ti -1c
.RI "\fBget\fP (self, in_ISR=False)"
.br
.RI "Read an item from the queue\&. "
.ti -1c
.RI "\fBany\fP (self)"
.br
.RI "Check if there are any items in the queue\&. "
.ti -1c
.RI "\fBempty\fP (self)"
.br
.RI "Check if the queue is empty\&. "
.ti -1c
.RI "\fBfull\fP (self)"
.br
.RI "Check if the queue is full\&. "
.ti -1c
.RI "\fBnum_in\fP (self)"
.br
.RI "Check how many items are in the queue\&. "
.ti -1c
.RI "\fBclear\fP (self)"
.br
.RI "Remove all contents from the queue\&. "
.ti -1c
.RI "\fB__repr__\fP (self)"
.br
.RI "This method puts diagnostic information about the queue into a string\&. "
.in -1c

Public Member Functions inherited from \fBtask_share\&.BaseShare\fP
.in +1c
.ti -1c
.RI "\fB__init__\fP (self, type_code, thread_protect=True, name=None)"
.br
.RI "Create a base queue object when called by a child class initializer\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "int \fBser_num\fP = 0"
.br
.RI "A counter used to give serial numbers to queues for diagnostic use\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fB_size\fP = size"
.br
.ti -1c
.RI "\fB_overwrite\fP = overwrite"
.br
.ti -1c
.RI "str \fB_name\fP"
.br
.ti -1c
.RI "\fB_buffer\fP = array\&.array (type_code, range (size))"
.br
.ti -1c
.RI "int \fB_wr_idx\fP = 0"
.br
.ti -1c
.RI "int \fB_num_items\fP = self\&._size"
.br
.ti -1c
.RI "# Record maximum fillage \fB_max_full\fP"
.br
.ti -1c
.RI "int \fB_rd_idx\fP = 0"
.br
.in -1c

Protected Attributes inherited from \fBtask_share\&.BaseShare\fP
.in +1c
.ti -1c
.RI "\fB_type_code\fP = type_code"
.br
.ti -1c
.RI "\fB_thread_protect\fP = thread_protect"
.br
.in -1c
.SH "Detailed Description"
.PP 
A queue which is used to transfer data from one task to another\&. 

If parameter 'thread_protect' is \fRTrue\fP when a queue is created, transfers of data will be protected from corruption in the case that one task might interrupt another due to use in a pre-emptive multithreading environment or due to one task being run as an interrupt service routine\&.

.PP
An example of the creation and use of a queue is as follows:

.PP
.PP
.nf
import task_share

# This queue holds unsigned short (16\-bit) integers
my_queue = task_share\&.Queue ('H', 100, name="My Queue")

# Somewhere in one task, put data into the queue
my_queue\&.put (some_data)

# In another task, read data from the queue
something = my_queue\&.get ()
.fi
.PP
 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "task_share\&.Queue\&.__init__ ( self,  type_code,  size,  thread_protect = \fRFalse\fP,  overwrite = \fRFalse\fP,  name = \fRNone\fP)"

.PP
Initialize a queue object to carry and buffer data between tasks\&. This method sets up a queue by allocating memory for the contents and setting up the components in an empty configuration\&.

.PP
Each queue can only carry data of one particular type which must be chosen from the following list\&. The data type is specified by a one-letter type code which is given as for the Python \fRarray\&.array\fP type, which can be any of the following: \fBb\fP (signed char)   \fBB\fP (unsigned char)   8 bit integers    \fBh\fP (signed short)   \fBH\fP (unsigned short)   16 bit integers    \fBi\fP (signed int)   \fBI\fP (unsigned int)   32 bit integers (probably)    \fBl\fP (signed long)   \fBL\fP (unsigned long)   32 bit integers    \fBq\fP (signed long long)   \fBQ\fP (unsigned long long)   64 bit integers    \fBf\fP (float)   \fBd\fP (double-precision float)   

.PP
\fBParameters\fP
.RS 4
\fItype_code\fP The type of data items which the queue can hold 
.br
\fIsize\fP The maximum number of items which the queue can hold 
.br
\fIthread_protect\fP \fRTrue\fP if mutual exclusion protection is used 
.br
\fIoverwrite\fP If \fRTrue\fP, oldest data will be overwritten with new data if the queue becomes full 
.br
\fIname\fP A short name for the queue, default \fRQueueN\fP where \fRN\fP is a serial number for the queue 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "task_share\&.Queue\&.__repr__ ( self)"

.PP
This method puts diagnostic information about the queue into a string\&. It shows the queue's name and type as well as the maximum number of items and queue size\&. 
.SS "task_share\&.Queue\&.any ( self)"

.PP
Check if there are any items in the queue\&. Returns \fRTrue\fP if there are any items in the queue and \fRFalse\fP if the queue is empty\&. 
.PP
\fBReturns\fP
.RS 4
\fRTrue\fP if items are in the queue, \fRFalse\fP if not 
.RE
.PP

.SS "task_share\&.Queue\&.clear ( self)"

.PP
Remove all contents from the queue\&. 
.SS "task_share\&.Queue\&.empty ( self)"

.PP
Check if the queue is empty\&. Returns \fRTrue\fP if there are no items in the queue and \fRFalse\fP if there are any items therein\&. 
.PP
\fBReturns\fP
.RS 4
\fRTrue\fP if queue is empty, \fRFalse\fP if it's not empty 
.RE
.PP

.SS "task_share\&.Queue\&.full ( self)"

.PP
Check if the queue is full\&. This method returns \fRTrue\fP if the queue is already full and there is no room for more data without overwriting existing data\&. 
.PP
\fBReturns\fP
.RS 4
\fRTrue\fP if the queue is full 
.RE
.PP

.SS "task_share\&.Queue\&.get ( self,  in_ISR = \fRFalse\fP)"

.PP
Read an item from the queue\&. If there isn't anything in there, wait (blocking the calling process) until something becomes available\&. If non-blocking reads are needed, one should call \fR\fBany()\fP\fP to check for items before attempting to read from the queue\&. This is usually done in a low priority task: 
.PP
.nf
def some_task ():
    # Setup
    while True:
        if my_queue\&.any ():
            something = my_queue\&.get ()
            do_something_with (something)
        # More loop stuff
        yield 0

.fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIin_ISR\fP Set this to \fRTrue\fP if calling from within an ISR 
.RE
.PP

.SS "task_share\&.Queue\&.num_in ( self)"

.PP
Check how many items are in the queue\&. This method returns the number of items which are currently in the queue\&. 
.PP
\fBReturns\fP
.RS 4
The number of items in the queue 
.RE
.PP

.SS "task_share\&.Queue\&.put ( self,  item,  in_ISR = \fRFalse\fP)"

.PP
Put an item into the queue\&. If there isn't room for the item, wait (blocking the calling process) until room becomes available, unless the \fRoverwrite\fP constructor parameter was set to \fRTrue\fP to allow old data to be clobbered\&. If non-blocking behavior without overwriting is needed, one should call \fR\fBfull()\fP\fP to ensure that the queue is not full before putting data into it: 
.PP
.nf
def some_task ():
    # Setup
    while True:
        if not my_queue\&.full ():
            my_queue\&.put (create_something_to_put ())
        yield 0

.fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIitem\fP The item to be placed into the queue 
.br
\fIin_ISR\fP Set this to \fRTrue\fP if calling from within an ISR 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "task_share\&.Queue\&._buffer = array\&.array (type_code, range (size))\fR [protected]\fP"

.SS "task_share\&.Queue\&._max_full\fR [protected]\fP"

.SS "task_share\&.Queue\&._name\fR [protected]\fP"
\fBInitial value:\fP
.nf
=  None \\
            else 'Queue' + str (Queue\&.ser_num)
.PP
.fi

.SS "task_share\&.Queue\&._num_items = self\&._size\fR [protected]\fP"

.SS "task_share\&.Queue\&._overwrite = overwrite\fR [protected]\fP"

.SS "int task_share\&.Queue\&._rd_idx = 0\fR [protected]\fP"

.SS "task_share\&.Queue\&._size = size\fR [protected]\fP"

.SS "int task_share\&.Queue\&._wr_idx = 0\fR [protected]\fP"

.SS "int task_share\&.Queue\&.ser_num = 0\fR [static]\fP"

.PP
A counter used to give serial numbers to queues for diagnostic use\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for MECHA-12 Romi from the source code\&.
