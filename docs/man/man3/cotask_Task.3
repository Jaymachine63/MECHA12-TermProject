.TH "cotask.Task" 3 "MECHA-12 Romi" \" -*- nroff -*-
.ad l
.nh
.SH NAME
cotask.Task \- Implements multitasking with scheduling and some performance logging\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB__init__\fP (self, run_fun, \fBname\fP='NoName', \fBpriority\fP=0, \fBperiod\fP=None, profile=False, trace=False, shares=())"
.br
.RI "Initialize a task object so it may be run by the scheduler\&. "
.ti -1c
.RI "bool \fBschedule\fP (self)"
.br
.RI "This method is called by the scheduler; it attempts to run this task\&. "
.ti -1c
.RI "bool \fBready\fP (self)"
.br
.RI "This method checks if the task is ready to run\&. "
.ti -1c
.RI "\fBset_period\fP (self, new_period)"
.br
.RI "This method sets the period between runs of the task to the given number of milliseconds, or \fRNone\fP if the task is triggered by calls to \fR\fBgo()\fP\fP rather than time\&. "
.ti -1c
.RI "\fBreset_profile\fP (self)"
.br
.RI "This method resets the variables used for execution time profiling\&. "
.ti -1c
.RI "\fBget_trace\fP (self)"
.br
.RI "This method returns a string containing the task's transition trace\&. "
.ti -1c
.RI "\fBgo\fP (self)"
.br
.RI "Method to set a flag so that this task indicates that it's ready to run\&. "
.ti -1c
.RI "\fB__repr__\fP (self)"
.br
.RI "This method converts the task to a string for diagnostic use\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBname\fP = name"
.br
.RI "The name of the task, hopefully a short and descriptive string\&. "
.ti -1c
.RI "\fBpriority\fP = int(priority)"
.br
.RI "The task's priority, an integer with higher numbers meaning higher priority\&. "
.ti -1c
.RI "int \fBperiod\fP = int(period * 1000)"
.br
.ti -1c
.RI "bool \fBgo_flag\fP = False"
.br
.RI "Flag which is set true when the task is ready to be run by the scheduler\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fB_run_gen\fP = run_fun(shares)"
.br
.ti -1c
.RI "\fB_next_run\fP = utime\&.ticks_us() + self\&.period"
.br
.ti -1c
.RI "\fB_prof\fP = profile"
.br
.ti -1c
.RI "int \fB_prev_state\fP = 0"
.br
.ti -1c
.RI "bool \fB_trace\fP = trace"
.br
.ti -1c
.RI "list \fB_tr_data\fP = []"
.br
.ti -1c
.RI "\fB_prev_time\fP = utime\&.ticks_us()"
.br
.ti -1c
.RI "int \fB_slowest\fP = runt"
.br
.ti -1c
.RI "int \fB_latest\fP = late"
.br
.ti -1c
.RI "int \fB_runs\fP = 0"
.br
.ti -1c
.RI "int \fB_run_sum\fP = 0"
.br
.ti -1c
.RI "int \fB_late_sum\fP = 0"
.br
.in -1c
.SH "Detailed Description"
.PP 
Implements multitasking with scheduling and some performance logging\&. 

This class implements behavior common to tasks in a cooperative multitasking system which runs in MicroPython\&. The ability to be scheduled on the basis of time or an external software trigger or interrupt is implemented, state transitions can be recorded, and run times can be profiled\&. The user's task code must be implemented in a generator which yields the state (and the CPU) after it has run for a short and bounded period of time\&.

.PP
\fBExample:\fP 
.PP
.nf
def task1_fun ():
     '''! This function switches states repeatedly for no reason '''
     state = 0
     while True:
         if state == 0:
             state = 1
         elif state == 1:
             state = 0
         yield (state)

 # In main routine, create this task and set it to run twice per second
 task1 = cotask\&.Task (task1_fun, name = 'Task 1', priority = 1, 
                      period = 500, profile = True, trace = True)

 # Add the task to the list (so it will be run) and run scheduler
 cotask\&.task_list\&.append (task1)
 while True: 
     cotask\&.task_list\&.pri_sched ()

.fi
.PP
 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "cotask\&.Task\&.__init__ ( self,  run_fun,  name = \fR'NoName'\fP,  priority = \fR0\fP,  period = \fRNone\fP,  profile = \fRFalse\fP,  trace = \fRFalse\fP,  shares = \fR()\fP)"

.PP
Initialize a task object so it may be run by the scheduler\&. This method initializes a task object, saving copies of constructor parameters and preparing an empty dictionary for states\&.

.PP
\fBParameters\fP
.RS 4
\fIrun_fun\fP The function which implements the task's code\&. It must be a generator which yields the current state\&. 
.br
\fIname\fP The name of the task, by default \fRNoName\fP\&. This should be overridden with a more descriptive name by the programmer\&. 
.br
\fIpriority\fP The priority of the task, a positive integer with higher numbers meaning higher priority (default 0) 
.br
\fIperiod\fP The time in milliseconds between runs of the task if it's run by a timer or \fRNone\fP if the task is not run by a timer\&. The time can be given in a \fRfloat\fP or \fRint\fP; it will be converted to microseconds for internal use by the scheduler\&. 
.br
\fIprofile\fP Set to \fRTrue\fP to enable run-time profiling 
.br
\fItrace\fP Set to \fRTrue\fP to generate a list of transitions between states\&. \fBNote:\fP This slows things down and allocates memory\&. 
.br
\fIshares\fP A list or tuple of shares and queues used by this task\&. If no list is given, no shares are passed to the task 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "cotask\&.Task\&.__repr__ ( self)"

.PP
This method converts the task to a string for diagnostic use\&. It shows information about the task, including execution time profiling results if profiling has been done\&. 
.PP
\fBReturns\fP
.RS 4
The string which represents the task 
.RE
.PP

.SS "cotask\&.Task\&.get_trace ( self)"

.PP
This method returns a string containing the task's transition trace\&. The trace is a set of tuples, each of which contains a time and the states from and to which the system transitioned\&. 
.PP
\fBReturns\fP
.RS 4
A possibly quite large string showing state transitions 
.RE
.PP

.SS "cotask\&.Task\&.go ( self)"

.PP
Method to set a flag so that this task indicates that it's ready to run\&. This method may be called from an interrupt service routine or from another task which has data that this task needs to process soon\&. 
.SS " bool cotask\&.Task\&.ready ( self)"

.PP
This method checks if the task is ready to run\&. If the task runs on a timer, this method checks what time it is; if not, this method checks the flag which indicates that the task is ready to go\&. This method may be overridden in descendent classes to implement some other behavior\&. 
.SS "cotask\&.Task\&.reset_profile ( self)"

.PP
This method resets the variables used for execution time profiling\&. This method is also used by \fR\fB__init__()\fP\fP to create the variables\&. 
.SS " bool cotask\&.Task\&.schedule ( self)"

.PP
This method is called by the scheduler; it attempts to run this task\&. If the task is not yet ready to run, this method returns \fRFalse\fP immediately; if this task is ready to run, it runs the task's generator up to the next \fRyield()\fP and then returns \fRTrue\fP\&.

.PP
\fBReturns\fP
.RS 4
\fRTrue\fP if the task ran or \fRFalse\fP if it did not 
.RE
.PP

.SS "cotask\&.Task\&.set_period ( self,  new_period)"

.PP
This method sets the period between runs of the task to the given number of milliseconds, or \fRNone\fP if the task is triggered by calls to \fR\fBgo()\fP\fP rather than time\&. 
.PP
\fBParameters\fP
.RS 4
\fInew_period\fP The new period in milliseconds between task runs 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "int cotask\&.Task\&._late_sum = 0\fR [protected]\fP"

.SS "int cotask\&.Task\&._latest = late\fR [protected]\fP"

.SS "cotask\&.Task\&._next_run = utime\&.ticks_us() + self\&.period\fR [protected]\fP"

.SS "int cotask\&.Task\&._prev_state = 0\fR [protected]\fP"

.SS "cotask\&.Task\&._prev_time = utime\&.ticks_us()\fR [protected]\fP"

.SS "cotask\&.Task\&._prof = profile\fR [protected]\fP"

.SS "cotask\&.Task\&._run_gen = run_fun(shares)\fR [protected]\fP"

.SS "int cotask\&.Task\&._run_sum = 0\fR [protected]\fP"

.SS "int cotask\&.Task\&._runs = 0\fR [protected]\fP"

.SS "int cotask\&.Task\&._slowest = runt\fR [protected]\fP"

.SS "list cotask\&.Task\&._tr_data = []\fR [protected]\fP"

.SS "bool cotask\&.Task\&._trace = trace\fR [protected]\fP"

.SS "bool cotask\&.Task\&.go_flag = False"

.PP
Flag which is set true when the task is ready to be run by the scheduler\&. 
.SS "cotask\&.Task\&.name = name"

.PP
The name of the task, hopefully a short and descriptive string\&. 
.SS "int cotask\&.Task\&.period = int(period * 1000)"

.SS "cotask\&.Task\&.priority = int(priority)"

.PP
The task's priority, an integer with higher numbers meaning higher priority\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for MECHA-12 Romi from the source code\&.
